.cpu cortex-m0
.thumb
.syntax unified
.fpu softvfp

//============================================================================
// Q1: hello
//============================================================================
.global hello
hello:
	PUSH {LR}
	LDR R0, =hello_t
	BL printf
	POP {PC}

//============================================================================
// Q2: add2
//============================================================================
.global add2
add2: //Assume a in R0, b in R1
	PUSH {LR}
	MOVS R2, R1
	MOVS R1, R0
	ADDS R3, R1, R2
	LDR R0, =add2_f
	BL printf
	POP {PC}

//============================================================================
// Q3: add3
//============================================================================
.global add3
add3: //Assume a in R0, b in R1, c in R2
	PUSH {LR}
	MOVS R3, R2
	MOVS R2, R1
	MOVS R1, R0
	LDR R0, =add3_f
	MOVS R4, #0
	ADDS R4, R1
	ADDS R4, R2
	ADDS R4, R3
	PUSH {R4}
	BL printf
	POP {R4, PC}

//============================================================================
// Q4: rotate6
//============================================================================
.global rotate6 //Does not work
rotate6: //R0 = a, R1 = b, R2 = c, R3 = d, R4 = e, R5 = f
	PUSH {R4-R7, LR}
	if1:
    	CMP R0, #0
    	BEQ continue
    	//Return
  		LDR R5, [SP, #20] //f
  		LDR R4, [SP, #24] //e
  		STR R4, [SP, #20] //Store e (r4) to f (R5)
  		STR R3, [SP, #24] //Store d to e
  		MOVS R3, R2
  		MOVS R2, R1
  		MOVS R1, R0
  		MOVS R0, R5
  		BL rotate6
  		B end_1
  	continue:
    	LDR R4, [SP, #24] //Load e
    	LDR R5, [SP, #20] //Load f
    	SUBS R5, R4
    	SUBS R5, R3
    	SUBS R5, R2
    	SUBS R5, R1
    	SUBS R5, R0
    	MOVS R0, R5
    end_1:

	POP {R4-R7, PC}

//============================================================================
// Q5: low_pattern
//============================================================================
.type compare, %function  // You knew you needed this line.  Of course you did!
compare:
        ldr  r0,[r0]
        ldr  r1,[r1]
        subs r0,r1
        bx lr

.global low_pattern
low_pattern: //nth = R0
	PUSH {R4-R7,LR}
  	MOVS R1, #0 //x
  	SUB SP, #400
  	SUB SP, #400
  	MOV R7, SP //Array starts at R7
  check1:
    CMP R1, #200
    BGE finish
  body:
    ADDS R2, R1, #1
    MOVS R3, #255
    MULS R3, R2
    LDR R4, =0xff
    ANDS R3, R4
    LSLS R6, R1, #2
    STR R3, [R7, R6]
    B check1
  finish:
  	MOVS R5, R0
  	MOVS R0, R7
  	MOVS R1, #200
  	MOVS R2, #4
  	LDR R3, =compare
  	BL qsort
  	MOVS R0, R5
  	LDR R0, [R7, R0]
  	ADD SP, R2
    POP {R4-R7,PC}


//============================================================================
// Q6: get_name
//============================================================================
.global get_name
get_name:
	PUSH {LR}
	SUB SP, #308 //Allocate Memory for buffer
	MOV R0, SP
	BL gets
	MOVS R1, R0
	LDR R0, =get_name_f
	BL printf
	POP {PC}

//============================================================================
// Q7: random_sum
//============================================================================
.global random_sum
random_sum:
	PUSH {LR}

	POP {PC}


//============================================================================
// Q8: fibn
//============================================================================
.global fibn
fibn:

//============================================================================
// Q9: fun
//============================================================================
.global fun
fun:

//============================================================================
// Q10: sick
//============================================================================
.global sick
sick:


//Strings

hello_t:
	.string "Hello, World!\n"
	.align 2

add2_f:
	.string "%d + %d = %d\n"
	.align 2

add3_f:
	.string "%d + %d + %d = %d\n"
	.align 2

get_name_f:
	.string "Hello, %s\n"
	.align 2

